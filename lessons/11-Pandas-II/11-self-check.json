[{"question": "What does the pd.json_normalize() function do that read_json() cannot?", "type": "multiple_choice", "code": null, "table": null, "precision": null, "answers": [{"answer": "It reads JSON files from disk", "correct": false, "feedback": "Both read_json() and json_normalize() can work with JSON data. The difference is in how they handle nested structures."}, {"answer": "It flattens nested JSON structures into columns", "correct": true, "feedback": "Correct! json_normalize() can flatten nested JSON, making nested keys accessible as separate columns (e.g., 'info.city', 'info.state')."}, {"answer": "It converts JSON to CSV format", "correct": false, "feedback": "Neither function converts to CSV. They both create DataFrames from JSON data."}, {"answer": "It validates JSON syntax", "correct": false, "feedback": "json_normalize() is for transforming JSON structure, not validating syntax."}]}, {"question": "From the lab: When scraping HTML tables with pd.read_html(url), what does the function return?", "type": "multiple_choice", "code": null, "table": null, "precision": null, "answers": [{"answer": "A single DataFrame containing the first table found", "correct": false, "feedback": "read_html() returns ALL tables found on the page, not just the first one."}, {"answer": "A list of DataFrames, one for each HTML table found on the page", "correct": true, "feedback": "Correct! read_html() returns a Python list containing a DataFrame for each table found. You need to use indexing to select the specific table you want."}, {"answer": "A dictionary with table names as keys", "correct": false, "feedback": "read_html() returns a list, not a dictionary. Tables are accessed by numeric index."}, {"answer": "A string containing the HTML source code", "correct": false, "feedback": "read_html() parses the HTML and returns DataFrames, not the raw HTML source."}]}, {"question": "What is the difference between pd.concat() and pd.merge()?", "type": "multiple_choice", "code": null, "table": null, "precision": null, "answers": [{"answer": "concat() is row-oriented (stacking DataFrames), merge() is column-oriented (joining on matching columns)", "correct": true, "feedback": "Correct! concat() appends DataFrames vertically (adding more rows), while merge() combines DataFrames horizontally based on common column values."}, {"answer": "concat() is column-oriented, merge() is row-oriented", "correct": false, "feedback": "This is backwards. concat() stacks rows, while merge() joins columns based on matching values."}, {"answer": "They do the same thing, just different syntax", "correct": false, "feedback": "They serve different purposes. concat() stacks DataFrames, merge() joins them on common columns."}, {"answer": "concat() only works with 2 DataFrames, merge() works with many", "correct": false, "feedback": "Actually, concat() can combine multiple DataFrames from a list, while merge() typically works with two at a time."}]}, {"question": "From the lab: In a pd.merge() operation, what does how='left' mean?", "type": "multiple_choice", "code": null, "table": null, "precision": null, "answers": [{"answer": "Only rows that match in both DataFrames", "correct": false, "feedback": "This describes how='inner'. A left join includes all rows from the left DataFrame."}, {"answer": "All rows from the left DataFrame plus any matches from the right DataFrame", "correct": true, "feedback": "Correct! A left join keeps all rows from the left DataFrame and adds matching data from the right. Non-matching rows from the right are excluded."}, {"answer": "All rows from the right DataFrame plus any matches from the left DataFrame", "correct": false, "feedback": "This describes how='right'. You have the concept backwards."}, {"answer": "All rows from both DataFrames whether they match or not", "correct": false, "feedback": "This describes how='outer'. A left join only keeps all rows from the left side."}]}, {"question": "What is the purpose of the lambda function in df.apply(lambda row: function(row['column']), axis=1)?", "type": "multiple_choice", "code": null, "table": null, "precision": null, "answers": [{"answer": "It creates a new DataFrame", "correct": false, "feedback": "The lambda doesn't create a DataFrame; it processes each row to generate values for a new column."}, {"answer": "It passes each row as a dictionary-like object to the custom function", "correct": true, "feedback": "Correct! The lambda function takes each row and extracts the specific column value(s) needed to pass to your custom function. axis=1 means apply across rows."}, {"answer": "It filters out unwanted rows", "correct": false, "feedback": "apply() with a lambda is for transformation, not filtering. Use boolean indexing for filtering."}, {"answer": "It sorts the DataFrame", "correct": false, "feedback": "apply() is for applying a function to rows/columns, not sorting. Use sort_values() for sorting."}]}, {"question": "Given this code, what will be the value of result?", "type": "numeric", "code": "import pandas as pd\nimport numpy as np\ndata = [{'a': 10, 'b': 20}, {'a': 15, 'b': 25}, {'a': 5, 'b': 30}]\ndf = pd.DataFrame(data)\ndf['c'] = df.apply(lambda row: row['a'] + row['b'], axis=1)\nresult = df['c'].mean()", "table": null, "precision": null, "answers": [{"type": "value", "value": 35.0, "correct": true, "feedback": "Correct! The 'c' column contains [30, 40, 35], and the mean is (30+40+35)/3 = 35."}, {"type": "default", "feedback": "Calculate the sum of each row (a+b) to create column c: [30, 40, 35], then find the mean: (30+40+35)/3."}]}, {"question": "From the homework: What Python module/function is used to parse a date string like '5/24/16' into a datetime object?", "type": "multiple_choice", "code": null, "table": null, "precision": null, "answers": [{"answer": "datetime.parse()", "correct": false, "feedback": "There is no parse() function in the datetime module. The correct function is strptime()."}, {"answer": "datetime.strptime()", "correct": true, "feedback": "Correct! datetime.strptime(datestring, format) parses a date string using the specified format and returns a datetime object."}, {"answer": "pd.to_datetime()", "correct": false, "feedback": "While this can work, the homework specifically asks you to use datetime.strptime() to practice date parsing with format codes."}, {"answer": "datetime.fromstring()", "correct": false, "feedback": "This function doesn't exist. The correct function is strptime()."}]}, {"question": "When using pd.json_normalize() with the record_path parameter, what does it do?", "type": "multiple_choice", "code": null, "table": null, "precision": null, "answers": [{"answer": "It specifies which nested JSON array to use as the row-level data", "correct": true, "feedback": "Correct! record_path sets which nested JSON key contains the array of records you want to expand into rows."}, {"answer": "It saves the normalized data to a file path", "correct": false, "feedback": "record_path is not about file paths; it's about specifying which nested JSON structure to expand."}, {"answer": "It removes duplicate records", "correct": false, "feedback": "record_path doesn't handle deduplication; it specifies which nested array to flatten."}, {"answer": "It records the path for error logging", "correct": false, "feedback": "record_path is for specifying which nested JSON array to normalize into rows."}]}, {"question": "From the homework: In the extract_colors() function, why do we lowercase the text before searching for colors?", "type": "multiple_choice", "code": null, "table": null, "precision": null, "answers": [{"answer": "To make the output look better", "correct": false, "feedback": "Lowercasing is not about output formatting; it's about improving the matching process."}, {"answer": "To improve color matching by making the search case-insensitive", "correct": true, "feedback": "Correct! Lowercasing both the text and curated colors ensures we match 'Red', 'RED', and 'red' consistently."}, {"answer": "Because the curated_colors list requires lowercase", "correct": false, "feedback": "While the curated list is lowercase, the main reason is to match colors regardless of how they're capitalized in the text."}, {"answer": "To remove special characters", "correct": false, "feedback": "Lowercasing converts case; it doesn't remove special characters."}]}, {"question": "What does the DataFrame.iterrows() method return?", "type": "multiple_choice", "code": null, "table": null, "precision": null, "answers": [{"answer": "A list of all rows in the DataFrame", "correct": false, "feedback": "iterrows() returns an iterator, not a list. You use it in a for loop."}, {"answer": "An iterator that yields (index, row) tuples where row is a dictionary-like Series", "correct": true, "feedback": "Correct! Similar to dict.items(), iterrows() yields (index, row) tuples where you can access row values like row['column_name']."}, {"answer": "Only the index values of the DataFrame", "correct": false, "feedback": "iterrows() returns both the index AND the row data as a tuple."}, {"answer": "A count of the number of rows", "correct": false, "feedback": "iterrows() is for iterating over rows, not counting them. Use len(df) to count rows."}]}]